{"pages":[],"posts":[{"title":"Python脚本工具篇之文本转码","text":"在UE中用JavaDoc格式注释的函数可以直接在蓝图的调用中看到注释内容，开发过程中的中文注释则会乱码，以及一些元数据说明符。 批量处理Source目录下的代码文件转码这里使用的是utf-8无签名(跨平台兼容) import os import sys from pathlib import Path import chardet #获取源码文件路径 project/source def getSourceDir(): return os.path.join(os.path.dirname(Path.cwd()),&quot;Source&quot;) #是否为代码文件 def isTargetFile(fileName): return fileName.rfind('.h')&gt;-1 or fileName.rfind('.cpp')&gt;-1 or fileName.rfind('.cs')&gt;-1 #获取文本的编码格式 def getFileEncode(filePath): f = open(filePath, 'rb') data = f.read() fileformat = chardet.detect(data)['encoding'] #print( chardet.detect(data)['confidence']) f.close() if fileformat == 'ISO-8859-9': #识别有误？！ fileformat = 'gbk' return fileformat #转换编码格式 def transformEnCoding(filePath,CurFileFormat,outFileFormat): with open(filePath, &quot;rb&quot;) as binaryfile: data = binaryfile.read() with open(filePath, &quot;wb&quot;) as binaryfile: dec = data.decode(CurFileFormat) #解码 res = dec.encode(outFileFormat) #编码 binaryfile.write(res) #写入 print('SourceFile:' + filePath.split('\\\\')[-1] + ' ' + CurFileFormat + ' To ' + outFileFormat + ' conversion successed') #遍历转换 def searchFile(TargetDir,outEncodeFormat): for root, dirs, files in os.walk(TargetDir): for filename in files: path = os.path.join(root, filename) if isTargetFile(path): tempEncodeFormat = getFileEncode(path) if tempEncodeFormat == outEncodeFormat: print('SourceFile:' + path.split('\\\\')[-1] + ' The target format does not need to be converted') else: transformEnCoding(path,tempEncodeFormat,outEncodeFormat) sys.exit() def TestEncodeFormat(TargetDir): for root, dirs, files in os.walk(TargetDir): for filename in files: path = os.path.join(root, filename) if isTargetFile(path): tempEncodeFormat = getFileEncode(path) print(path+' '+ tempEncodeFormat) if __name__ == '__main__': searchFile(getSourceDir(),'utf-8')","link":"/2019/10/07/Python%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%E6%96%87%E6%9C%AC%E8%BD%AC%E7%A0%81/"},{"title":"UE4 LoadingScreen实践","text":"最近项目中需要制作跳转关卡的Loading界面，整理一下已知的一些思路。 游戏中的关卡加载在UE中主要分为2种，以LevelStream异步加载和OpenLevel的方式。LevelStream异步加载：当异步线程加载关卡资源时，游戏线程会有明显的卡顿现象。OpenLevel：在主线程加载关卡资源，直接阻塞线程，造成画面直接卡死直到资源加载完成。 Loading UI在关卡加载过程中，对Loading页面表现效果并不友好。就算是异步加载，Loading页面的一些动态效果也会一卡一顿。OpenLevel更不用说了。而且对于OpenLevel来说，当完成关卡加载后会移除以Add to Viewport添加到视口的UI。 制作思路： 1.完全假的，Loading页面（效果可以接受的话）。切换关卡之前完成LoadingUI的一些效果展示，然后再进行OpenLevel之类的操作。 2.使用MoviePlayer的方式， 代码示例： 先在Build.cs中添加“MoviePlayer”模块 void ULoadMapGameInstance::Init() { Super::Init(); FCoreUObjectDelegates::PreLoadMap.AddUObject(this, &amp;ULoadMapGameInstance::PreLoadMap); //绑定回调 FCoreUObjectDelegates::PostLoadMapWithWorld.AddUObject(this, &amp;ULoadMapGameInstance::PostLoadMap); LoadingUI = CreateWidget&lt;ULoadingUserWidget&gt;(this, LoadClass&lt;ULoadingUserWidget&gt;(this, TEXT(&quot;WidgetBlueprint'/Game/LoadingUI/LoadingUI.LoadingUI_C'&quot;))); } void ULoadMapGameInstance::PreLoadMap(const FString&amp; Map) { GEngine-&gt;AddOnScreenDebugMessage(-1, 20.f, FColor::Red, Map); if (Map.Contains(&quot;Showcase&quot;)) { FLoadingScreenAttributes LSA; LSA.bWaitForManualStop = true; //当关卡加载完成时，手动关闭UI显示 // LSA.WidgetLoadingScreen = LoadingUI-&gt;TakeWidget(); LSA.WidgetLoadingScreen = FLoadingScreenAttributes::NewTestLoadingScreenWidget(); GetMoviePlayer()-&gt;SetupLoadingScreen(LSA); // LoadingUI-&gt;StartLoading(); } } void ULoadMapGameInstance::PostLoadMap(UWorld* World) { GEngine-&gt;AddOnScreenDebugMessage(-1, 20.f, FColor::Red, TEXT(&quot;loaded--------&quot;)); // LoadingUI-&gt;OverLoading(); } 这种方式适合在OpenLevel的情况下使用，LoadingUI 建议使用Slate来写，部分UserWidget中的控制在这种情况下无法显示。 补充在Editor启动统计指令 “Stat Levels” 以异步加载关卡的时候，能看到关卡加载进度，个人暂时没有什么比较好的方法拿到Stat中的数据。关于FStatsThreadState一些接口在”StatsData.h”中。 参考：UE4 Doc以及ActionRPG","link":"/2019/06/08/UE4-LoadingScreen%E5%AE%9E%E8%B7%B5/"},{"title":"UE4 项目集成第三方库整理","text":"记录一下使用过程中的一些细节和碰到的坑 关于库在UE4中需要使用自己制作第三方库需要注意的几点（Windows）：1.库工程的解决方案配置必须为Release,解决方案平台看自己需要。2.静态库需要使用到对应类的头文件和.lib文件，制作静态库时最好分.h.cpp。3.动态库自需要注意导出函数的声明。 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。 对于小体量单个程序使用的库来说生成静态库或者动态库区别不大，大型多个程序使用的库还是推荐使用动态库。 静态库在UE4的使用由于是使用库提供的一些接口，最好还是新建一个模块来集成，不建议直接在PRIMARY_GAME_MODULE使用，优点在于可以根据需求来加载卸载。这里使用插件新建一个模块：需要在PluginName.build.cs配置好库的路径。 工程目录：这里重点是Plugin目录 库的头文件路径：temp\\Plugins\\Al3ix\\Source\\ThirdParty\\MyTestLibrary\\include.lib文件路径：temp\\Plugins\\Al3ix\\Source\\ThirdParty\\MyTestLibrary\\x64PluginName.build.cs文件路径：（这里Al3ix和ThirdParty在同一个目录下）temp\\Plugins\\Al3ix\\Source\\Al3ix PluginName.build.cs 代码： // Copyright 1998-2019 Epic Games, Inc. All Rights Reserved. using System.IO; //注意添加这个文件的引用，不然会提示没有Path这个成员 using UnrealBuildTool; public class Al3ix : ModuleRules { public Al3ix(ReadOnlyTargetRules Target) : base(Target) { PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs; PublicIncludePaths.AddRange( new string[] { // ... add public include paths required here ... } ); PrivateIncludePaths.AddRange( new string[] { // ... add other private include paths required here ... } ); PublicDependencyModuleNames.AddRange( new string[] { &quot;Core&quot;, &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;Al3ixLibrary&quot;, &quot;Projects&quot; // ... add other public dependencies that you statically link with here ... } ); PrivateDependencyModuleNames.AddRange( new string[] { // ... add private dependencies that you statically link with here ... } ); DynamicallyLoadedModuleNames.AddRange( new string[] { // ... add any modules that your module loads dynamically here ... } ); //重点部分===================================== //需要依赖的静态库根路径 string MyTestLibRootPath = Path.Combine(ThirdPartyPath, &quot;MyTestLibrary&quot;); //分平台加载 if(Target.Platform == UnrealTargetPlatform.Win64) { PublicIncludePaths.Add(Path.Combine(MyTestLibRootPath, &quot;include&quot;)); PublicLibraryPaths.Add(Path.Combine(MyTestLibRootPath, &quot;x64&quot;)); PublicAdditionalLibraries.Add(&quot;Al3ixLibrary.lib&quot;); } } //第三方静态库根路径 private string ThirdPartyPath { get { return Path.GetFullPath(Path.Combine(ModuleDirectory, &quot;../ThirdParty&quot;)); } } } 这里通过虚幻的UBT会自动加载对应路径的头文件和.lib 不需要像普通C++项目在项目熟悉中添加库相关依赖。在Plugin模块新建类文件，直接#include “库接口对应的头文件.h” 可以使用相对路径，就可以使用库提供的接口了。 补充如果编译报错，或者提示.lib文件无法打开，一般是build.cs中配置的路径错了。error LNK2038: 检测到“ITERATOR_DEBUG_LEVEL”的不匹配项 这种就是库工程的解决方案配置是Debug改为Release就行了","link":"/2019/05/01/UE4-%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%95%B4%E7%90%86/"},{"title":"UE4 关于字符串的处理","text":"关于不同平台一些字符串处理的问题 前言字符集以及编码格式简介字符集是指包括各国家文字、标点符号、图形符号、数字等的一个集合。常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。 ASCII：作用：表语英语及西欧语言。位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。范围：ASCII从00到7F，扩展从00到FF。GB：双字节编码范围：A1A1~FEFEA1-A9：符号区，包含682个符号B0-F7：汉字区，包含6763个汉字GB2312：作用：国家简体中文字符集，兼容ASCII。位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码 Unicode字符集Unicode是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。需要说明的是，定长编码便于计算机处理（注意GB2312/GBK不是定长编码），而unicode又可以用来表示所有字符，所以在很多软件内部是使用unicode编码来处理的。Unicode字符集有多个编码方式UTF-8，UTF-16，UTF-32和UTF-7编码等。 C++中 char与wchar_twindows平台 char 表示单字符，占用一个字节，对应的字符集是扩展的ANSI wchar_t 表示宽字符，占用两个字节，UFT16每一个字符都需要一个两个字节，用wchar_t表示。windows平台下的TCHAR类型就是通过宏对char和wchar_t的封装。可根据当前平台情况选择对应的类型。_T修饰的字符串常量同理，根据是否定义的UNICODE宏，分别表示””或L””。 UE4中的字符串UE4中的所有字符串都作为FStrings或TCHAR数组以UTF-16 格式存储在内存中。大多数代码假设2个字节等于一个代码点，因此只支持基本多文种平面（BMP），这样虚幻内部编码可以更准确地描述为UCS-2。字符串以适合于当前平台的字节次序存储。当向/从磁盘序列化到程序包，或在联网期间序列化时，TCHAR字符小于0xff的字符串均存储为一串8位字节，否则存储为双字节UTF-16字符串。序列化代码可以根据需要处理任何字节次序转换。 设置字符串变量文字时应使用 TEXT() 宏。如未指定 TEXT() 宏，将使用 ANSI 对文字进行编码，会导致支持字符高度受限。传入 FString 的 ANSI 文字需要完成到 TCHAR 的转换（本地万国码编码），以便更高效地使用 TEXT()。 wchar_t，TCHAR，FString之间的隐式转换： wchar_t* temp = L&quot;爱我中华&quot;; UE_LOG(LogTemp, Log, TEXT(&quot;wchar_t Content is : %s&quot;), temp); TCHAR* tch = temp; UE_LOG(LogTemp, Log, TEXT(&quot;TCHAR Content is : %s&quot;), tch); FString str = temp; UE_LOG(LogTemp, Log, TEXT(&quot;FString Content is : %s&quot;), *str); LogTemp: wchar_t Content is : 爱我中华 LogTemp: TCHAR Content is : 爱我中华 LogTemp: FString Content is : 爱我中华 UE4的宏转换：这些宏可以将字符串转换为各种编码或从各种编码转换字符串。这些宏使用局部范围内声明的类实例，在堆栈上分配空间，因此保留指向这些宏的指针非常重要！它们仅用于将字符串传递给函数调用。TCHAR_TO_ANSI(str)TCHAR_TO_OEM(str)ANSI_TO_TCHAR(str)TCHAR_TO_UTF8(str)UTF8_TO_TCHAR(str) 这里如果使用带中文的字符串转换成ANCI字符串，输出会出现乱码的情况。 最后不建议在C++代码中直接使用字符串文字进行硬编码，这类数据可以存储在INT和INI文件中。如果有需要，可以对C++代码使用BOM的UTF-8编码（VS2019中为Unicode(UTF-8 带签名)）","link":"/2019/04/29/UE4-%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%84%E7%90%86/"},{"title":"UE4内存管理","text":"在项目前期会需要有一些业务模块的核心类Manager类等，需要手动管理。UE也提供了完整的解决方案，在此整理一下。 在UE中默认只有UObject或者UObject的子类创建的对象才会被UE管理GC。（UStruct不在其中，可以使用智能指针） CPlusPlus智能指针管理： //赋值一次增加一次引用计数，当计数为0时，自动释放内存 TSharedPtr&lt;CPlusPlusClass&gt; T_SafeObj = MakeShareable(new CPlusPlusClass); 继承FGCObject防止被引用的C++对象被GC： CPlusPlusClass(CPlusPlusClass* OtherCPPClass) : SafeObj(OtherCPPClass) {}; ~CPlusPlusClass(); void AddReferencedObjects(FReferenceCollector&amp; Collector) override { //防止此对象被GC，调用析构函数时，FReferenceCollector将自动清除其所添加的所有引用 Collector.AddReferencedObject(SafeObj); } UObjectUObject实现了GC不能使用智能指针管理 防止被自动GC：1.UPROPERTY()引用 UPROPERTY() UObjectClass* SafeUObject; 2.被容器引用 UObjectClass* SafeUObject; AActorClass(); AActorClass(UObjectClass* UObj) :SafeUObject(UObj) { //添加的被UPROPERTY标记的容器中 TestTArray.Add(UObj); TestMap.Add(1, UObj); TestSet.Add(UObj); }; UPROPERTY() TArray&lt;UObjectClass*&gt; TestTArray; UPROPERTY() TMap&lt;int32, UObjectClass*&gt; TestMap; UPROPERTY() TSet&lt;UObjectClass*&gt; TestSet; 3.添加到根集 //保证不会被GC SafeUObject-&gt;AddToRoot(); //手动释放 SafeUObject-&gt;RemoveFromRoot(); SafeUObject = nullptr; ActorActor创建后需要手动销毁，调用Destroy()后，标记为等待销毁(IsPendingKill()此时返回True),等待下次GC释放内存。如果有大量Actor需要销毁，可以强制执行GC释放内容(卡顿警告) void NowFree() { for (AActor* Temp : ManyActors) { Temp-&gt;Destroy(); } //强制执行一次GC： GWorld-&gt;GetWorld()-&gt;ForceGarbageCollection(true); } ActorComponent 同Actor,调用DestroyComponent()后，等待下次GC释放。 随笔整理一下哈！","link":"/2019/07/21/UE4%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"UI优化篇","text":"内存，游戏线程，渲染线程的优化操作。 内存优化主要针对贴图的优化。 合并贴图（例如Texturepacker），按项目需求来合并贴图，例如按单个UI合并，类型合并（武器图标这种）。单个较大的贴图不要合并，例如背景图片这种。合并后的贴图大小比之前每个贴图之和的大小要省不少内存（简单暴力）。 使用UE的Sprite工具可以自动切分贴图：（Spirte操作-&gt;提取Sprite） 当UI可能需要隐藏时（并未销毁），可以考虑释放UTexture2D引用的内存： void UUserWidgetOptimizationExample::LoadTexture() { if (MyTexture==nullptr) { MyTexture = LoadObject&lt;UTexture2D&gt;(NULL, TEXT(&quot;PaperSprite'/Game/UI/T_2x2_Sprite_4.T_2x2_Sprite_4'&quot;)); } } void UUserWidgetOptimizationExample::FreeTexture() { if (IsValid(MyTexture)) { MyTexture-&gt;ConditionalBeginDestroy(); MyTexture = NULL; GetWorld()-&gt;ForceGarbageCollection(true); } } 游戏线程1.尽量使用事件驱动UI更新代替事件绑定 2.控件的Visbility:按钮使用Visbility, \\ 使用Collapsed代替Hidden \\ 无需交互的控件使用SelfHitTestInvisible或者HitTestInvisible 3.InvalidationBox缓存控件避免在重复使用，状态不稳定的控件中使用 渲染线程1.尽量使用能合并的容器：VerticalBoxHorizontalBoxGridPanelUniformGridPanel 2.RetainerBox分帧渲染增加显存开销主界面使用 3.合并贴图","link":"/2019/07/24/UI%E4%BC%98%E5%8C%96%E7%AF%87/"},{"title":"卡通材质Toon-Shader","text":"制作一个基本的卡通材质 about toon-shader关于卡通材质官方给出的解释： 上图可以看出来卡通材质主要两个特征：描边，色块化 接下来创建一个后处理材质，开始制作（这里关于后处理体积如何使用不做过多赘述） 描边外轮廓描边由于轮廓边缘像素深度值与轮廓外像素深度值有比较大的差值（一般是大于轮廓边缘）将通过每个像素的DepthBuffer跟周围它上下左右的像素进行差值，就可以拿到上下左右的外轮廓信息。主要节点SceneDepth代码片段（左边部分）最后把上下左右的计算结果Add连到自发光上： 内轮廓描边内轮廓描边需要通过法线计算,计算过程类似外轮廓计算。主要节点WorldNormal代码片段： 色块 颜色之间有明显的过度，硬边，硬阴影代码片段： 最后成果 最后看看效果图： 总结避免使用高模，不适用于前向渲染不适用于半透明物体（需要设置Blendable Loaction:BeforeTranslucency） 参考：官方YOUTUBE","link":"/2019/04/20/%E5%8D%A1%E9%80%9A%E6%9D%90%E8%B4%A8Toon-Shader/"},{"title":"开放大世界引擎性能优化工具","text":"在处理开放世界地形，UE中提供的一些优化工具 一.Landscapes Debug: ALT + L 显示或隐藏 二.关于植被：1.根据机器性能，调整每一种植被的密度/数量2.扩展密度3.带碰撞的Mesh,不会渲染但碰撞不会移除，所以一般关闭碰撞 Procedural Volumes：可以自定义植被覆盖的规则 三.World composition:根据距离来加载和卸载关卡 不执行流送，需要通过程序来控制加载项目设置 Use Background LevelStreaming 可以创建关卡LOD相当于创建新关卡为当前关卡的简化版，并且把所有的StaticMesh收集到一起，仅创建一个StaticMesh,可以提供给关卡所有地形使用，LOD关卡将使用两次绘制调用（一个地形Mesh,一个其他Mesh合并的Mesh）。 LOD Level设置: 相关Command：Stat Levels 查看关卡加载进度强制GC，恢复流出的关卡占用的内存s.ForceGCAfterLevelStreamedOut是否在流化级别之后强制执行GC，以便在发生故障的情况下立即回收内存。s.UseBackgroundLevelStreaming是否允许后台流媒体 四.降低渲染开销：1.控制可见性尽量为每个物体设置距离剔除剔除体积 减少像素着色器的成本r.screenpercentage 10捕获r.RHISetGPUCaptureOptions 1 2.低多边形/LOD 自定义LOD组： 可以按配置好的规格设置LOD的参数 也可以使用EditorUtilityWidgetBlueprint一次性为大量资源设置LOD LOD：较少GPU负载不减少Drawcall增加加载时间和内存使用 3.合并Actor 开发者工具-&gt;合并Actor减少Drawcall,许多Mesh使用同样的材质进一步可以合并材质。 代理几何体工具：提取网格体，体素化 生成新的网格体和材质合并操作，可以较少Drawcall 但是可能增加GPU负载（视锥剔除） HLOD。关卡启用HLOD（略） 4.使用Instance静态网格","link":"/2019/10/08/%E5%BC%80%E6%94%BE%E5%A4%A7%E4%B8%96%E7%95%8C%E5%BC%95%E6%93%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/"},{"title":"开篇","text":"前言 一路走来，坎坎坷坷，总算是坚持了下来。 在此，感谢帮助过我的朋友，谢谢你们。 近日，偶有所感，决定记录下学习过程中的一些点滴。 于是就这样开始了…","link":"/2019/04/20/%E5%BC%80%E7%AF%87/"},{"title":"网络同步","text":"总结下UE4中网络同步的一些细节 基础UE4中网络同步主要通过两种方式：属性复制、RPC调用。Actor是网络同步中基本单位。属性复制： 复制的属性值发生变化时，服务器会向所有客户端发送更新。只存在于Server同步到Client(1.标记为复制的属性不需要在客户端修改，如果服务端此属性不变化，客户端的值不会被修正;2.不是经常变动的属性尽量不使用复制，减少CPU消耗)PRC： 可以双向调用;实时性由于属性复制;客户端同步到服务端只能通过RPC;以及作弊验证。(1.必须从Actor上调用,而且Actor：Replicate=true;2.RPC的调用与Actor的Owned相关) 条件复制合理使用DOREPLIFETIME_CONDITION,值得注意的是以下几个： DOREPLIFETIME：复制到所有连接端。 COND_InitialOnly ： 属性在开始的时候同步，只同步一次。 COND_Custom : 配合DOREPLIFETIME_ACTIVE_OVERRIDE使用 相关性bOnlyRelevanttoOwner ：该Ator只同步给它所有者bAlwaysRelevant ： 默认生成时由Pawn或PlayerController拥有与每个玩家都相关，每个玩家都能收到该actor的信息,一般动态设置owner，但是像playerstate就是默认owner是controller ,playerstate的AlwaysRelevant是默认勾选的bNetUseOwnerRelevanc : 使用owner的相关性，比如owner是个复制品，自己就是复制品，如果owner是自主代理，自己就是自主代理，但是用的还是自己的actorchannel 优先级优先级比例等同于更新频度，UE给出的参考值：Actor = 1.0Matinee = 2.7Pawn = 3.0PlayerController = 3.0 补充：1、勾选了bReplicate的Actor无法正常在Client创建（Role是ROLE_Authority，RemoteRole是ROLE_None）2、Actor的BeginPlay会在Server和Client都执行，Server优先执行3、GameInstance不参与网络复制,GameMode只存在于Server4、PlayerState存储Player的信息，会同步到所有的Client5、RepNotify/ReplicatedUsing 一般用于距离控制，属性同步过来的一些更新操作6、RPC函数是不能有返回值，RPC的参数限制 UObject,const FString,FVector_NetQuantizeNormal等等7、UStruct的属性同步，子结构体会递归的进行同步。不想同步，需要在对应的属性标记NotReplicated8、组件同步动态创建的组件须要attach到Actor上并设置他的Replicate属性为true，AActorComponent::SetIsReplicated(true) 补上之前看到的一张图：","link":"/2019/09/22/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"}],"tags":[{"name":"UE4 Loading UI","slug":"UE4-Loading-UI","link":"/tags/UE4-Loading-UI/"},{"name":"UE4","slug":"UE4","link":"/tags/UE4/"},{"name":"UE4内存管理","slug":"UE4内存管理","link":"/tags/UE4%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"材质 卡通渲染","slug":"材质-卡通渲染","link":"/tags/%E6%9D%90%E8%B4%A8-%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93/"}],"categories":[]}